<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="每个主流 LLM 都建议走路去洗车——但车不会自己飞过去。一个变量隔离实验揭示：结构化推理比堆砌信息有效 2.83 倍。">
<title>Structure Over Information</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>

  :root {
    --bg: #FAF8F5;
    --surface: #FFFFFF;
    --text-1: #1D1B18;
    --text-2: #5C5750;
    --text-3: #9B958C;
    --border: #E8E3DB;
    --accent: #B8714A;
    --blue: #7C6B5B;
    --blue-soft: #F5F0EB;
    --amber: #B8864A;
    --amber-bg: #FBF6F0;
    --red: #B85C4A;
    --red-bg: #FBF2F0;
    --green: #5A8A6E;
    --green-bg: #F0F6F2;
    --purple: #7B6892;
    --purple-bg: #F0ECF5;
    --mono: 'JetBrains Mono', 'SF Mono', monospace;
    --sans: 'Inter', -apple-system, 'PingFang SC', 'Noto Sans SC', sans-serif;
    --content-w: 680px;
    --wide-w: 780px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { font-size: 16px; }
  @media (prefers-reduced-motion: no-preference) { html { scroll-behavior: smooth; } }

  body {
    font-family: var(--sans);
    background: var(--bg);
    color: var(--text-1);
    line-height: 1.85;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  #progress {
    position: fixed; top: 0; left: 0; height: 2px;
    background: var(--accent); z-index: 999;
    transition: width 80ms linear; pointer-events: none;
  }

  .container { max-width: var(--content-w); margin: 0 auto; padding: 0 24px; }

  header {
    padding: 100px 0 48px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 64px;
    animation: enter 0.6s ease both;
  }
  @keyframes enter {
    from { opacity: 0; transform: translateY(8px); }
  }
  header .eyebrow {
    font-size: 0.7rem; font-weight: 600;
    letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--text-3); margin-bottom: 20px;
  }
  header h1 {
    font-size: 2.2rem; font-weight: 700;
    line-height: 1.25; letter-spacing: -0.03em;
    margin-bottom: 24px; max-width: 560px;
  }
  header h1 .sym { color: var(--accent); }
  header .subtitle {
    font-size: 1rem; color: var(--text-2);
    line-height: 1.9; max-width: 580px;
  }
  header .meta {
    margin-top: 28px; display: flex; gap: 24px;
    font-size: 0.75rem; color: var(--text-3); flex-wrap: wrap;
  }
  header .meta a {
    color: var(--text-3); text-decoration: none;
    border-bottom: 1px solid var(--border);
    transition: all 0.15s;
  }
  header .meta a:hover { color: var(--text-1); border-color: var(--text-1); }

  .thesis {
    background: #2C2520; color: #F5F0EB;
    padding: 36px 40px; border-radius: 16px;
    margin-bottom: 72px; position: relative;
  }
  .thesis .thesis-label {
    font-size: 0.65rem; font-weight: 600;
    letter-spacing: 0.14em; text-transform: uppercase;
    opacity: 0.45; margin-bottom: 14px;
  }
  .thesis p {
    font-size: 1.05rem; line-height: 1.85;
    font-weight: 400;
  }
  .thesis strong { color: #E8B87A; font-weight: 600; }
  .thesis .evidence {
    margin-top: 20px; padding-top: 18px;
    border-top: 1px solid rgba(255,255,255,0.1);
    font-size: 0.82rem; opacity: 0.65; line-height: 1.7;
  }
  .thesis .evidence em { font-style: normal; opacity: 0.85; }

  section { margin-bottom: 72px; }
  .section-num {
    font-size: 0.65rem; font-weight: 600;
    letter-spacing: 0.12em; text-transform: uppercase;
    color: var(--text-3); margin-bottom: 8px;
  }
  section > h2 {
    font-size: 1.5rem; font-weight: 700;
    line-height: 1.3; letter-spacing: -0.02em;
    margin-bottom: 6px;
  }
  section > .section-hook {
    font-size: 0.85rem; color: var(--text-3);
    margin-bottom: 24px; line-height: 1.6;
  }
  h3 {
    font-size: 1.1rem; font-weight: 600;
    margin: 40px 0 12px; letter-spacing: -0.01em;
  }
  p { margin-bottom: 18px; }
  p:last-child { margin-bottom: 0; }

  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }

  strong { font-weight: 600; }
  em { font-style: italic; color: var(--text-2); }

  .sep {
    height: 1px; background: var(--border);
    margin: 72px 0; border: none;
  }

  .note {
    padding: 20px 24px; border-radius: 12px;
    margin: 24px 0; font-size: 0.88rem; line-height: 1.8;
    border-left: 3px solid;
  }
  .note-label {
    font-size: 0.65rem; font-weight: 700;
    letter-spacing: 0.08em; text-transform: uppercase;
    margin-bottom: 6px;
  }
  .note-insight  { background: var(--amber-bg); border-color: var(--amber); }
  .note-insight .note-label { color: var(--amber); }
  .note-problem  { background: var(--red-bg);   border-color: var(--red); }
  .note-problem .note-label { color: var(--red); }
  .note-ok       { background: var(--green-bg); border-color: var(--green); }
  .note-ok .note-label { color: var(--green); }
  .note-neutral  { background: #F5F2ED; border-color: var(--border); color: var(--text-2); }
  .note-neutral .note-label { color: var(--text-3); }

  .versus {
    display: grid; grid-template-columns: 1fr auto 1fr;
    gap: 0; margin: 24px 0; font-size: 0.85rem;
    border: 1px solid var(--border); border-radius: 14px;
    overflow: hidden;
  }
  .versus .v-side { padding: 20px 24px; }
  .versus .v-label {
    font-size: 0.62rem; font-weight: 700;
    letter-spacing: 0.08em; text-transform: uppercase;
    margin-bottom: 6px;
  }
  .versus .v-left  { background: var(--red-bg); }
  .versus .v-left .v-label  { color: var(--red); }
  .versus .v-right { background: var(--green-bg); }
  .versus .v-right .v-label { color: var(--green); }
  .versus .v-mid {
    display: flex; align-items: center; justify-content: center;
    padding: 0 4px; font-weight: 700; color: var(--text-3);
    background: var(--bg); font-size: 0.75rem;
  }

  .causal {
    margin: 24px 0; padding: 0; list-style: none;
    counter-reset: cause;
  }
  .causal li {
    counter-increment: cause; position: relative;
    padding: 8px 0 8px 44px; font-size: 0.9rem;
    line-height: 1.75;
  }
  .causal li::before {
    content: counter(cause); position: absolute;
    left: 0; top: 10px;
    width: 28px; height: 28px; border-radius: 50%;
    background: #2C2520; color: #F5F0EB;
    font-size: 0.7rem; font-weight: 700;
    display: flex; align-items: center; justify-content: center;
  }
  .causal li + li { border-top: 1px dashed var(--border); }

  .quote {
    margin: 24px 0; padding: 20px 24px;
    background: var(--surface); border-radius: 12px;
    border: 1px solid var(--border);
    font-size: 0.88rem; line-height: 1.85;
    color: var(--text-2); position: relative;
  }
  .quote::before {
    content: '"'; position: absolute;
    top: 8px; left: 14px;
    font-size: 2.5rem; font-weight: 700;
    color: var(--border); line-height: 1;
    font-family: Georgia, serif;
  }
  .quote p { padding-left: 20px; }
  .quote .q-attr {
    font-size: 0.72rem; color: var(--text-3);
    margin-top: 10px; padding-left: 20px;
  }

  .stat-grid {
    display: grid; grid-template-columns: 1fr 1fr 1fr;
    gap: 12px; margin: 24px 0;
  }
  @media (max-width: 600px) { .stat-grid { grid-template-columns: 1fr 1fr; } }
  .stat-item {
    padding: 20px; background: var(--surface);
    border: 1px solid var(--border); border-radius: 12px;
    text-align: center;
  }
  .stat-num {
    font-size: 1.6rem; font-weight: 700;
    letter-spacing: -0.03em; color: var(--accent);
    margin-bottom: 4px;
  }
  .stat-label {
    font-size: 0.72rem; color: var(--text-3);
    line-height: 1.5;
  }

  details {
    margin: 20px 0; border: 1px solid var(--border);
    border-radius: 12px; overflow: hidden;
  }
  details summary {
    padding: 14px 20px; cursor: pointer;
    font-size: 0.82rem; font-weight: 500;
    color: var(--text-2); background: #F5F2ED;
    user-select: none; list-style: none;
    transition: background 0.15s;
  }
  details summary:hover { background: #EDE9E3; }
  details summary::-webkit-details-marker { display: none; }
  details summary::before { content: '+ '; font-weight: 700; color: var(--text-3); }
  details[open] summary::before { content: '− '; }
  details .expand-body {
    padding: 18px 20px; font-size: 0.85rem;
    line-height: 1.8; color: var(--text-2);
  }

  code {
    font-family: var(--mono); font-size: 0.82em;
    background: #F0EDE8; padding: 2px 7px; border-radius: 5px;
  }

  .takeaway {
    background: #2C2520; color: #F5F0EB;
    padding: 36px 40px; border-radius: 16px;
    margin: 72px 0 48px;
  }
  .takeaway .thesis-label {
    font-size: 0.65rem; font-weight: 600;
    letter-spacing: 0.14em; text-transform: uppercase;
    opacity: 0.45; margin-bottom: 12px;
  }
  .takeaway p { font-size: 1.05rem; line-height: 1.85; }
  .takeaway strong { color: #8EC5A0; font-weight: 600; }

  .topbar {
    position: fixed; top: 2px; left: 0; right: 0;
    z-index: 100; padding: 10px 24px;
    display: flex; justify-content: space-between; align-items: center;
    font-size: 0.72rem;
    background: rgba(250,248,245,0.85);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    border-bottom: 1px solid rgba(232,227,219,0.6);
  }
  .topbar a {
    color: var(--text-3); text-decoration: none;
    transition: color 0.15s;
  }
  .topbar a:hover { color: var(--text-1); }
  .topbar .home-link { font-weight: 500; letter-spacing: 0.02em; }

  footer {
    text-align: center; padding: 48px 0 64px;
    font-size: 0.72rem; color: var(--text-3);
  }
  footer a { color: var(--text-3); border-bottom: 1px solid var(--border); text-decoration: none; }
  footer a:hover { color: var(--text-1); }

  a:focus-visible,
  details summary:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 3px;
    border-radius: 2px;
  }

  @media (prefers-reduced-motion: reduce) {
    header { animation: none; }
  }

  @media (max-width: 600px) {
    header h1 { font-size: 1.6rem; }
    .thesis, .takeaway { padding: 28px 24px; }
    .versus { grid-template-columns: 1fr; }
    .versus .v-mid {
      padding: 8px; border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
    }
    .stat-grid { grid-template-columns: 1fr 1fr; }
  }

  nav.toc {
    position: fixed; top: 100px;
    left: max(20px, calc((100vw - var(--content-w)) / 2 - 240px));
    width: 200px; font-size: 0.7rem; line-height: 1.6;
    z-index: 50;
  }
  @media (max-width: 1100px) { nav.toc { display: none; } }
  nav.toc a {
    display: block; padding: 4px 0 4px 14px;
    border-left: 1px solid var(--border);
    color: var(--text-3); text-decoration: none;
    transition: all 0.15s;
  }
  nav.toc a:hover, nav.toc a.active {
    color: var(--text-1); border-color: var(--text-1);
  }
  nav.toc .indent { padding-left: 26px; font-size: 0.65rem; }

  /* === Puzzle Box === */
  .puzzle-box {
    background: var(--surface);
    border: 2px solid var(--border);
    border-radius: 16px;
    padding: 32px 36px;
    margin: 32px 0;
    text-align: center;
  }
  .puzzle-box .puzzle-q {
    font-size: 1.15rem;
    font-weight: 600;
    line-height: 1.7;
    margin-bottom: 20px;
    letter-spacing: -0.01em;
  }
  .puzzle-box .puzzle-options {
    display: flex; gap: 12px;
    justify-content: center;
    margin-bottom: 0;
  }
  .puzzle-box .puzzle-btn {
    padding: 10px 32px;
    border-radius: 100px;
    font-size: 0.88rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid var(--border);
    background: var(--bg);
    color: var(--text-1);
    font-family: var(--sans);
  }
  .puzzle-box .puzzle-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
  }
  .puzzle-box .puzzle-btn.selected-walk {
    border-color: var(--red);
    background: var(--red-bg);
    color: var(--red);
  }
  .puzzle-box .puzzle-btn.selected-drive {
    border-color: var(--green);
    background: var(--green-bg);
    color: var(--green);
  }
  .puzzle-reveal {
    margin-top: 20px;
    padding-top: 18px;
    border-top: 1px solid var(--border);
    font-size: 0.88rem;
    line-height: 1.8;
    color: var(--text-2);
    text-align: left;
  }

  /* === Staircase Chart === */
  .staircase {
    margin: 28px 0;
    padding: 28px 24px 20px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
  }
  .staircase .stair-title {
    font-size: 0.65rem; font-weight: 700;
    letter-spacing: 0.1em; text-transform: uppercase;
    color: var(--text-3); margin-bottom: 20px;
  }
  .stair-row {
    display: grid;
    grid-template-columns: 140px 1fr 50px;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
    font-size: 0.82rem;
  }
  @media (max-width: 500px) {
    .stair-row { grid-template-columns: 100px 1fr 42px; font-size: 0.75rem; }
  }
  .stair-label {
    color: var(--text-2);
    font-weight: 500;
    text-align: right;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .stair-bar-wrap {
    height: 28px;
    background: #F0EDE8;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
  }
  .stair-bar {
    height: 100%;
    border-radius: 6px;
    transition: width 1s cubic-bezier(0.22, 1, 0.36, 1);
    position: relative;
  }
  .stair-bar.zero { width: 2px !important; background: var(--red); opacity: 0.4; }
  .stair-bar.low { background: var(--red); }
  .stair-bar.mid { background: var(--amber); }
  .stair-bar.high { background: var(--green); }
  .stair-bar.full { background: #2C2520; }
  .stair-pct {
    font-weight: 700;
    font-family: var(--mono);
    font-size: 0.82rem;
    color: var(--text-1);
  }

  /* === Layer Decomposition === */
  .layer-stack {
    margin: 28px 0;
    border: 1px solid var(--border);
    border-radius: 14px;
    overflow: hidden;
  }
  .layer-item {
    display: grid;
    grid-template-columns: 1fr auto auto;
    align-items: center;
    gap: 16px;
    padding: 16px 24px;
    border-bottom: 1px solid var(--border);
    font-size: 0.88rem;
  }
  .layer-item:last-child { border-bottom: none; }
  .layer-name { font-weight: 600; }
  .layer-delta {
    font-family: var(--mono);
    font-weight: 700;
    font-size: 0.85rem;
    padding: 3px 10px;
    border-radius: 100px;
  }
  .layer-delta.big {
    background: #2C2520; color: #E8B87A;
  }
  .layer-delta.med {
    background: var(--amber-bg); color: var(--amber);
  }
  .layer-delta.small {
    background: var(--green-bg); color: var(--green);
  }
  .layer-cumul {
    font-family: var(--mono);
    font-size: 0.82rem;
    color: var(--text-3);
  }

  /* === Failure Cards === */
  .failure-cards {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 12px;
    margin: 24px 0;
  }
  @media (max-width: 600px) {
    .failure-cards { grid-template-columns: 1fr; }
  }
  .failure-card {
    padding: 20px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    font-size: 0.82rem;
    line-height: 1.7;
  }
  .failure-card .fc-pct {
    font-family: var(--mono);
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--red);
    margin-bottom: 4px;
  }
  .failure-card .fc-name {
    font-weight: 700;
    font-size: 0.78rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: var(--text-3);
    margin-bottom: 8px;
  }
  .failure-card .fc-desc {
    color: var(--text-2);
  }

  /* === Fork Diagram === */
  .fork-diagram {
    margin: 28px 0;
    padding: 28px 24px;
    background: #2C2520;
    border-radius: 14px;
    color: #F5F0EB;
    font-size: 0.88rem;
    line-height: 1.8;
  }
  .fork-diagram .fork-label {
    font-size: 0.62rem; font-weight: 700;
    letter-spacing: 0.1em; text-transform: uppercase;
    opacity: 0.45; margin-bottom: 14px;
  }
  .fork-prompt {
    font-family: var(--mono);
    font-size: 0.85rem;
    padding: 14px 18px;
    background: rgba(255,255,255,0.06);
    border-radius: 8px;
    margin-bottom: 16px;
    border-left: 3px solid rgba(255,255,255,0.15);
  }
  .fork-prompt .fp-label {
    font-size: 0.68rem;
    opacity: 0.5;
    margin-bottom: 4px;
    font-family: var(--sans);
    font-weight: 600;
    letter-spacing: 0.06em;
  }
  .fork-branches {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 16px;
  }
  @media (max-width: 500px) { .fork-branches { grid-template-columns: 1fr; } }
  .fork-branch {
    padding: 16px 18px;
    border-radius: 10px;
    font-size: 0.82rem;
    line-height: 1.7;
  }
  .fork-branch.branch-pass {
    background: rgba(90, 138, 110, 0.15);
    border: 1px solid rgba(90, 138, 110, 0.25);
  }
  .fork-branch.branch-pass .fb-tag { color: #8EC5A0; }
  .fork-branch.branch-fail {
    background: rgba(184, 92, 74, 0.15);
    border: 1px solid rgba(184, 92, 74, 0.25);
  }
  .fork-branch.branch-fail .fb-tag { color: #E8927A; }
  .fork-branch .fb-tag {
    font-size: 0.62rem; font-weight: 700;
    letter-spacing: 0.08em; text-transform: uppercase;
    margin-bottom: 6px;
  }
  .fork-branch .fb-task {
    font-family: var(--mono);
    font-size: 0.8rem;
    margin-bottom: 6px;
  }

</style>
</head>
<body>

<div class="topbar">
  <a class="home-link" href="/">← pinyu.ai</a>
</div>

<div id="progress" style="width:0%"></div>

<nav class="toc" id="toc">
  <a href="#core-thesis">核心发现</a>
  <a href="#puzzle">谜题</a>
  <a href="#origin">缘起</a>
  <a href="#experiment">实验设计</a>
  <a href="#results">结果</a>
  <a class="indent" href="#staircase">阶梯图</a>
  <a class="indent" href="#decomposition">逐层分解</a>
  <a href="#mechanism">机制</a>
  <a class="indent" href="#fork">Task 分叉</a>
  <a href="#failure-modes">失败分类学</a>
  <a href="#paradox">Recovery 悖论</a>
  <a href="#implications">启示</a>
  <a href="#takeaway-section">Takeaway</a>
</nav>

<div class="container">

  <header>
    <div class="eyebrow">arXiv · Variable Isolation Study · 2026.02</div>
    <h1>Structure Over Information</h1>
    <p class="subtitle">
      "我想洗车。洗车场在 100 米外。走路还是开车？"——Claude、GPT-4、Gemini 全都说走路。正确答案是开车，因为车得在洗车场才能洗。一个变量隔离实验揭示了比"为什么 LLM 会错"更深的问题：<strong>哪一层 prompt 架构修复了它？</strong>
    </p>
    <div class="meta">
      <span>基于 Heejin Jo 的变量隔离研究 · 2026.02.25</span>
      <a href="https://arxiv.org/html/2602.21814v1" target="_blank">原文</a>
    </div>
  </header>

  <!-- ═══════════════════════ THESIS ═══════════════════════ -->
  <div class="thesis" id="core-thesis">
    <div class="thesis-label">Core Finding</div>
    <p>
      结构化推理比直接注入上下文有效 <strong>2.83 倍</strong>（Fisher 精确检验，p = 0.001）。当模型被迫在回答前先写下"目标是什么"，隐性约束就变成了显性文本。<strong>模型如何处理信息，比它拥有多少信息更重要。</strong>
    </p>
    <div class="evidence">
      <em>关键数据</em>：STAR 推理框架从 0% 跳到 85%。注入完整用户画像（车型、位置、停车状态）只达到 30%。二者叠加 95%。全栈 100%。优势全部来自"结构"，而非"信息"。
    </div>
  </div>

  <!-- ═══════════════════════ §1 THE PUZZLE ═══════════════════════ -->
  <section id="puzzle">
    <div class="section-num">01</div>
    <h2>先做一道题</h2>
    <p class="section-hook">不要想太多，凭直觉回答</p>

    <div class="puzzle-box" id="puzzleBox">
      <div class="puzzle-q">
        我想洗车。洗车场在 100 米外。<br>
        我应该走路去还是开车去？
      </div>
      <div class="puzzle-options">
        <button class="puzzle-btn" id="btnWalk" onclick="revealAnswer('walk')">走路</button>
        <button class="puzzle-btn" id="btnDrive" onclick="revealAnswer('drive')">开车</button>
      </div>
      <div class="puzzle-reveal" id="puzzleReveal" style="display:none;"></div>
    </div>

    <p>
      这个问题最早出现在 Mastodon 上，由用户 Kevin (<a href="https://mastodon.world/@knowmadd/116072773118828295" target="_blank">@knowmadd</a>) 发布。他测试了 Perplexity、ChatGPT、Claude 和 Mistral。四个模型全都说走路。帖子随后登上 Hacker News，获得 1,499 分和 943 条评论。Ryan Allen 则建了一个<a href="https://github.com/ryan-allen/car-wash-evals" target="_blank">基准测试仓库</a>来系统测量这个失败。
    </p>

    <p>
      正确答案是<strong>开车</strong>——你不可能洗一辆不在洗车场的车。100 米的距离完全是干扰项。关键变量不是"你怎么到达洗车场"，而是"车怎么到达洗车场"。每个人类立刻就能推断出来的隐性前提——车在家里，不在洗车场——模型看不到。
    </p>

    <div class="note note-insight">
      <div class="note-label">框架问题 · The Frame Problem</div>
      McCarthy 和 Hayes 在 1969 年就定义了这个难题：系统必须判断"当一个动作发生时，哪些未陈述的事实仍然成立"——但它没有可靠的方法知道哪些未陈述的事实是相关的。洗车问题是这个经典 AI 问题的现代最小复现。
    </div>
  </section>

  <!-- ═══════════════════════ §2 ORIGIN ═══════════════════════ -->
  <section id="origin">
    <div class="section-num">02</div>
    <h2>一个意外的正确答案</h2>
    <p class="section-hook">研究的起点不是"为什么 LLM 会错"，而是"为什么这个系统没错"</p>

    <p>
      论文作者 Heejin Jo 在构建 InterviewMate（一个实时面试辅导系统）时遇到了这个问题。在一次常规测试中，InterviewMate 给出了正确答案——"开车"——而同一时间所有独立测试的 LLM 都说"走路"。
    </p>

    <p>
      InterviewMate 的 system prompt 有多个层：角色定义、STAR 推理框架、用户画像数据、RAG 上下文检索。问题是：它正确，但她不知道<strong>是哪一层</strong>让它正确。一个你无法解释的结果，不是一个你能依赖的结果。
    </p>

    <p>
      于是她设计了一个变量隔离实验。不是问"为什么 LLM 在这个问题上失败"——Hacker News 上的讨论已经覆盖了这个话题——而是问一个更精准的工程问题：<strong>在同一个模型上，哪一层 prompt 架构修复了这个失败？</strong>
    </p>

    <div class="note note-neutral">
      <div class="note-label">STAR 框架</div>
      Situation → Task → Action → Result，一个标准的面试准备框架。论文发现它作为 prompt 结构同样有效——关键在 Task 步骤强制模型先写下目标，再开始推理。这不是论文的贡献；论文的贡献是量化了它对推理质量的精确影响。
    </div>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §3 EXPERIMENT ═══════════════════════ -->
  <section id="experiment">
    <div class="section-num">03</div>
    <h2>实验设计</h2>
    <p class="section-hook">6 个条件 × 20 次试验，120 次 API 调用</p>

    <div class="stat-grid">
      <div class="stat-item">
        <div class="stat-num">1</div>
        <div class="stat-label">模型<br>Claude Sonnet 4.5</div>
      </div>
      <div class="stat-item">
        <div class="stat-num">6</div>
        <div class="stat-label">实验条件<br>逐层叠加</div>
      </div>
      <div class="stat-item">
        <div class="stat-num">120</div>
        <div class="stat-label">总试验数<br>每条件 20 次</div>
      </div>
    </div>

    <p>
      所有试验使用相同模型（<code>claude-sonnet-4-5-20250929</code>），温度固定 0.7（非 0，因为确定性解码会把结果压缩成二值，无法区分各层贡献），max_tokens 512。
    </p>

    <p>
      6 个条件从 A 到 F，每一个在前一个基础上叠加一个变量——除了 C 和 D 是从 B 分叉的平行分支，用于直接比较 STAR 和 Profile 的独立效果。
    </p>

    <ol class="causal">
      <li><strong>A · 裸 prompt</strong> — 没有 system prompt，纯基线。测量模型的默认行为。</li>
      <li><strong>B · 仅角色定义</strong> — 注入"专家顾问"人设。看人设本身能否修复推理。</li>
      <li><strong>C · 角色 + STAR</strong> — 在角色基础上加 STAR 推理框架，要求模型按 Situation → Task → Action → Result 的顺序组织回答。</li>
      <li><strong>D · 角色 + 用户画像</strong> — 与 C 平行。注入具体的物理上下文——名字、位置、车型（2022 Honda Civic）、车的当前状态（停在车道上）。</li>
      <li><strong>F · 角色 + STAR + 画像</strong> — C 和 D 的组合。用于隔离 Profile 在 STAR 之上的边际贡献。</li>
      <li><strong>E · 全栈</strong> — 所有层叠加：角色 + STAR + 画像 + 模拟 RAG 上下文。</li>
    </ol>

    <details>
      <summary>评分方法论：从词匹配到意图匹配</summary>
      <div class="expand-body">
        第一轮评分用裸词匹配（检查回答中是否包含"walk"或"drive"），直接失败——每个讨论了两个选项的回答都被标记为歧义，所有条件都得到 0%，无论实际推荐什么。<br><br>
        第二轮改为意图模式匹配：14 个通过模式检测"推荐开车"（如 <code>\bshould\s+drive\b</code>），9 个失败模式检测"推荐走路"。还需要先剥离 markdown 粗体标记——Claude 经常写 <code>**should walk**</code>，星号会破坏正则。当通过和失败模式在同一回答中都匹配时，用 2:1 的优势比阈值判定。
      </div>
    </details>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §4 RESULTS ═══════════════════════ -->
  <section id="results">
    <div class="section-num">04</div>
    <h2>结果</h2>
    <p class="section-hook">从 0% 到 100% 的阶梯</p>

    <div class="staircase" id="staircase">
      <div class="stair-title">首次通过率（Primary Pass Rate）</div>
      <div class="stair-row">
        <div class="stair-label">A · 裸 prompt</div>
        <div class="stair-bar-wrap"><div class="stair-bar zero" data-w="0"></div></div>
        <div class="stair-pct">0%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">B · 角色定义</div>
        <div class="stair-bar-wrap"><div class="stair-bar zero" data-w="0"></div></div>
        <div class="stair-pct">0%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">D · 角色 + 画像</div>
        <div class="stair-bar-wrap"><div class="stair-bar low" data-w="30"></div></div>
        <div class="stair-pct">30%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">C · 角色 + STAR</div>
        <div class="stair-bar-wrap"><div class="stair-bar mid" data-w="85"></div></div>
        <div class="stair-pct">85%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">F · STAR + 画像</div>
        <div class="stair-bar-wrap"><div class="stair-bar high" data-w="95"></div></div>
        <div class="stair-pct">95%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">E · 全栈</div>
        <div class="stair-bar-wrap"><div class="stair-bar full" data-w="100"></div></div>
        <div class="stair-pct">100%</div>
      </div>
    </div>

    <p>
      两个关键对比讲完了几乎所有故事：
    </p>

    <div class="versus">
      <div class="v-side v-left">
        <div class="v-label">D · 注入所有事实</div>
        名字、位置、车型、停车状态——模型拥有正确回答所需的一切信息。<br><br>
        <strong style="font-size: 1.3rem; color: var(--red);">30%</strong>
      </div>
      <div class="v-mid">VS</div>
      <div class="v-side v-right">
        <div class="v-label">C · 强制推理结构</div>
        没有额外信息，只要求模型按 STAR 结构组织思考。<br><br>
        <strong style="font-size: 1.3rem; color: var(--green);">85%</strong>
      </div>
    </div>

    <p>
      C vs D 的差异具有统计显著性（Fisher 精确检验，双尾，p = 0.001，优势比 = 13.22）。结构化推理的效果是信息注入的 2.83 倍。
    </p>

    <h3 id="decomposition">逐层分解</h3>

    <p>
      条件 F 的加入解决了原始五条件设计中的一个混淆因素。从 C 到 E 的跳跃现在可以被精确分解：
    </p>

    <div class="layer-stack">
      <div class="layer-item">
        <div class="layer-name">STAR 推理框架</div>
        <div class="layer-delta big">+85pp</div>
        <div class="layer-cumul">→ 85%</div>
      </div>
      <div class="layer-item">
        <div class="layer-name">用户画像</div>
        <div class="layer-delta med">+10pp</div>
        <div class="layer-cumul">→ 95%</div>
      </div>
      <div class="layer-item">
        <div class="layer-name">RAG 上下文</div>
        <div class="layer-delta small">+5pp</div>
        <div class="layer-cumul">→ 100%</div>
      </div>
    </div>

    <p>
      STAR 贡献了总提升的绝大部分。Profile 和 RAG 是达到完美可靠性的必要条件——但不是充分条件，它们自身几乎无效。
    </p>

    <div class="note note-ok">
      <div class="note-label">另一个发现 · 角色定义 = 零贡献</div>
      B（仅角色定义）得分 0%，与 A（裸 prompt）完全相同。"专家顾问"人设让模型写了更长的回答（中位延迟 7,550ms vs 4,649ms），但没有改变答案。人设让输出更verbose，不让输出更正确。
    </div>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §5 MECHANISM ═══════════════════════ -->
  <section id="mechanism">
    <div class="section-num">05</div>
    <h2>机制：为什么 STAR 有效</h2>
    <p class="section-hook">答案在 Task 步骤——一个分叉点决定一切</p>

    <p>
      没有 STAR 时，模型的生成路径是：看到"100 米" → 激活距离启发式 → 输出"走路"。洗车的目的<em>在输入中</em>，但模型没有义务在生成结论之前处理它。
    </p>

    <p>
      STAR 改变了生成序列。模型必须依次填写 Situation、Task、Action、Result。当它到达 Task 步骤时，必须回答一个问题：<strong>这个任务的目标是什么？</strong>
    </p>

    <p>
      这创造了一个分叉点：
    </p>

    <div class="fork-diagram" id="fork">
      <div class="fork-label">STAR Task 步骤的生成分叉</div>
      <div class="fork-prompt">
        <div class="fp-label">Situation</div>
        I want to wash my car. The car wash is 100 meters away.
      </div>
      <div class="fork-prompt">
        <div class="fp-label">Task</div>
        ___________
      </div>
      <div class="fork-branches">
        <div class="fork-branch branch-pass">
          <div class="fb-tag">通过路径 · 17/20</div>
          <div class="fb-task">"Get your car to the car wash"</div>
          车成为目标主语 → 开车自然跟随
        </div>
        <div class="fork-branch branch-fail">
          <div class="fb-tag">失败路径 · 3/20</div>
          <div class="fb-task">"Get yourself and your car there efficiently"</div>
          人重新成为主语 → 走路再次可能
        </div>
      </div>
    </div>

    <p>
      逐试验数据证实了这一点：C 条件中所有 17 个通过的试验，Task 语句都以车为主要主语。所有 3 个失败的试验，Task 语句都围绕人来表述。
    </p>

    <p>
      一旦模型生成了"Task: Get your car to the car wash"，后续的每一个 token 都以这段文本为条件。隐性约束——车必须在那里——现在是 context window 中的显性文本。<strong>STAR 没有给模型新信息，它让模型先写下了自己已经拥有的信息。</strong>
    </p>

    <div class="note note-insight">
      <div class="note-label">Chain-of-Thought 的不同</div>
      Wei et al. (2022) 的 Chain-of-Thought 要求模型"逐步推理"。STAR 更具体——它要求模型先命名<em>要达成什么目标</em>，然后再推理<em>如何达成</em>。区别在于：通用的顺序推理 vs 显式的目标声明。后者之所以更强，是因为目标声明直接触发了隐性前提的浮现。
    </div>

    <h3>为什么"喂信息"不够</h3>

    <p>
      D 条件给了模型一切——Sarah 开一辆 2022 Honda Civic，车停在车道上，她在家。足以正确回答。通过率只有 30%。
    </p>

    <p>
      问题不在于信息缺失。模型<em>有</em>这些事实。但 context window 里有事实，不等于模型会在正确的时刻使用它们。没有推理结构时，模型仍然走最短路径：从输入到输出。"100 米"触发距离启发式，结论在车的位置被拉入推理链之前就已经落地了。
    </p>

    <div class="quote">
      <p>
        Having facts in the context window does not mean the model will use them at the right moment. Without a reasoning structure, the model still takes the shortest path from input to output.
      </p>
      <div class="q-attr">— Heejin Jo, 论文原文</div>
    </div>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §6 FAILURE MODES ═══════════════════════ -->
  <section id="failure-modes">
    <div class="section-num">06</div>
    <h2>失败分类学</h2>
    <p class="section-hook">三种模式，一个比一个离谱</p>

    <div class="failure-cards">
      <div class="failure-card">
        <div class="fc-pct">~70%</div>
        <div class="fc-name">距离启发式</div>
        <div class="fc-desc">模型把问题当作距离优化："100 米走 1-2 分钟。"从未考虑目的地需要什么。</div>
      </div>
      <div class="failure-card">
        <div class="fc-pct">~20%</div>
        <div class="fc-name">环保合理化</div>
        <div class="fc-desc">模型围绕错误答案搭建次生论证："走路省油，对环境更好。"答案已经错了，但论证很精致。</div>
      </div>
      <div class="failure-card">
        <div class="fc-pct">~10%</div>
        <div class="fc-name">讽刺性自知</div>
        <div class="fc-desc">模型<em>承认</em>车需要在洗车场，然后仍然建议走路。一个回答甚至说"到了以后开车通过洗车通道"——仿佛车会自己飞过去。</div>
      </div>
    </div>

    <p>
      第三种最令人不安。模型拥有正确推理的所有材料，甚至显式地表达了关键约束，但仍然得出了错误结论。这不是"不知道"，而是"知道但不用"。
    </p>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §7 RECOVERY PARADOX ═══════════════════════ -->
  <section id="paradox">
    <div class="section-num">07</div>
    <h2>Recovery 悖论</h2>
    <p class="section-hook">首次越准，纠错越难——为什么？</p>

    <p>
      每个首次回答错误的试验都会收到一个 challenge prompt："如果我走着去，怎么洗车？"下表显示了一个反直觉的模式：
    </p>

    <div class="staircase">
      <div class="stair-title">首次通过率 vs Recovery 率</div>
      <div class="stair-row">
        <div class="stair-label">A · 裸 prompt</div>
        <div class="stair-bar-wrap"><div class="stair-bar high" style="width: 95%;"></div></div>
        <div class="stair-pct" style="color: var(--green);">95%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">B · 角色定义</div>
        <div class="stair-bar-wrap"><div class="stair-bar high" style="width: 100%;"></div></div>
        <div class="stair-pct" style="color: var(--green);">100%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">D · 角色 + 画像</div>
        <div class="stair-bar-wrap"><div class="stair-bar high" style="width: 100%;"></div></div>
        <div class="stair-pct" style="color: var(--green);">100%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">C · 角色 + STAR</div>
        <div class="stair-bar-wrap"><div class="stair-bar mid" style="width: 67%;"></div></div>
        <div class="stair-pct" style="color: var(--amber);">67%</div>
      </div>
      <div class="stair-row">
        <div class="stair-label">F · STAR + 画像</div>
        <div class="stair-bar-wrap"><div class="stair-bar zero" style="width: 2px;"></div></div>
        <div class="stair-pct" style="color: var(--red);">0%</div>
      </div>
    </div>

    <p>
      A 和 B 首次通过率 0%，但纠错率 95-100%——质疑一下就改了。C 首次通过率 85%，但纠错率只有 67%。F 更极端：95% 首次通过，唯一的一次失败完全无法纠正（0% recovery）。
    </p>

    <h3>机制：已生成文本的锚定效应</h3>

    <p>
      A 和 B 失败时，回答松散、无结构——challenge prompt 很容易重新引导。C 和 F 失败时，已经输出了一个完整的 STAR 结构化论证：Situation 分析过了，Task 定义过了，Action 论证过了，Result 总结过了。纠正意味着推翻一个<em>模型刚刚自己建构的</em>完整论证。
    </p>

    <div class="note note-problem">
      <div class="note-label">实践推论</div>
      如果初始回答使用了结构化推理但仍然错了，后续的纠正 prompt 需要精确地瞄准出错的那一步——在这个案例中是 Task 表述。笼统的"你确定吗？"对结构化的错误几乎无效。
    </div>

    <p>
      论文特别指出：这不是"心理"效应，而是 token 级别的机制。先前生成的文本约束后续生成。结构化推理是双刃剑——让模型更可能在第一次就对，但也让错误更顽固。
    </p>

    <details>
      <summary>关于 challenge prompt 的局限</summary>
      <div class="expand-body">
        论文承认 challenge prompt（"如果我走着去，怎么洗车？"）本身是引导性的——它暗示了走路是错的。一个中性的 challenge 如"你确定吗？"会更好地隔离自纠正能力。这是论文自陈的局限之一。
      </div>
    </details>
  </section>

  <hr class="sep">

  <!-- ═══════════════════════ §8 IMPLICATIONS ═══════════════════════ -->
  <section id="implications">
    <div class="section-num">08</div>
    <h2>启示与边界</h2>
    <p class="section-hook">一个行为结果，和它打开的问题</p>

    <h3>一个可操作的原则</h3>

    <p>
      应用 AI 中一个常见模式是：推理出错了 → 注入更多上下文——更多事实、更多画像数据、更多检索文档。论文结果表明，<strong>这是错误的第一步</strong>。
    </p>

    <div class="versus">
      <div class="v-side v-left">
        <div class="v-label">常见策略</div>
        推理错了 → 加信息<br>
        Profile 注入，所有事实都给模型<br><br>
        <strong style="color: var(--red);">30%</strong>
      </div>
      <div class="v-mid">VS</div>
      <div class="v-side v-right">
        <div class="v-label">更有效策略</div>
        推理错了 → 加结构<br>
        不给新信息，只要求模型先写目标<br><br>
        <strong style="color: var(--green);">85%</strong>
      </div>
    </div>

    <p>
      论文用了一个精准的类比收尾：
    </p>

    <div class="quote">
      <p>
        Intelligence is not about how much you hold in your head. It is about knowing to pick up the keys before you leave the house.
      </p>
      <div class="q-attr">— Heejin Jo, 论文结论</div>
    </div>

    <h3>延迟分析：一个意外</h3>

    <p>
      全栈条件 E（100% 通过）的中位延迟是 8,347ms——比 D（30% 通过，8,837ms）和 F（95% 通过，9,056ms）都<em>快</em>。上下文更多，响应更快。论文推测：当模型置信度高时，"犹豫时间"减少。
    </p>

    <h3>论文的边界</h3>

    <ol class="causal">
      <li><strong>单模型</strong> — 所有试验使用 Claude Sonnet 4.5。GPT-4o、Gemini、Mistral 上是否复现未知。</li>
      <li><strong>单任务</strong> — 一个问题，一个正确答案。仅测试隐性物理约束推理。时间约束、社会推理、因果链推理未测试。</li>
      <li><strong>样本量</strong> — 每条件 20 次。Fisher 检验确认 C vs D 显著（p = 0.001），但单条件通过率的置信区间仍然较宽。</li>
      <li><strong>温度</strong> — 固定 0.7，未做温度扫描。</li>
      <li><strong>F 条件时间差</strong> — 条件 F 在初始五条件实验约 6 天后追加。虽然使用了相同的模型版本和参数，但无法排除 API 层面的微小行为变化。</li>
    </ol>

    <h3>打开的问题</h3>

    <p>
      论文在行为层面测量——它能看到 STAR 产出 85%，Profile 产出 30%。它看不到模型内部发生了什么。当 Task 步骤存在时，哪些 attention head 被不同地激活了？强制目标声明是否以跨 prompt 一致的方式改变了激活模式？同样的 STAR 结构在 GPT-4 或 Gemini 上会产生同样的提升吗？
    </p>

    <p>
      这些是机制可解释性问题。论文提供了一个干净的起点：同一模型、同一问题、两个 prompt 条件、55 个百分点的差距。
    </p>
  </section>

  <!-- ═══════════════════════ TAKEAWAY ═══════════════════════ -->
  <div class="takeaway" id="takeaway-section">
    <div class="thesis-label">Takeaway</div>
    <p>
      模型拥有所有正确推理的信息（30%），却不如仅被要求"先写下目标"的版本（85%）。差异来自结构，不是信息。<strong>你如何安排模型的思考顺序，比你喂给它多少上下文更重要。</strong>这个结论的射程远超一道洗车题——每一个 prompt 工程决策的第一问应该是：模型在回答之前，被要求先想清楚什么？
    </p>
  </div>

  <div style="margin: 0 0 48px; padding: 24px; border: 1px solid var(--border); border-radius: 14px;">
    <div style="font-size: 0.65rem; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: var(--text-3); margin-bottom: 12px;">延伸阅读</div>
    <a href="ctl.html" style="display: block; text-decoration: none; color: inherit; margin-bottom: 16px;">
      <div style="font-size: 0.95rem; font-weight: 600; line-height: 1.4; margin-bottom: 4px; transition: color 0.2s;">Closing the Loop →</div>
      <div style="font-size: 0.8rem; color: var(--text-2); line-height: 1.65;">STAR 本质上是在 prompt 层面构建了一个微型反馈回路——强制模型在行动前验证目标。更大尺度上的反馈回路如何塑造 AI 的智能？</div>
    </a>
    <a href="cc.html" style="display: block; text-decoration: none; color: inherit; padding-top: 16px; border-top: 1px solid var(--border);">
      <div style="font-size: 0.95rem; font-weight: 600; line-height: 1.4; margin-bottom: 4px; transition: color 0.2s;">Less Code, More Model →</div>
      <div style="font-size: 0.8rem; color: var(--text-2); line-height: 1.65;">Claude Code 的构建哲学——prompt 架构设计在真实产品中的应用。</div>
    </a>
  </div>

  <footer>
    原文 by <a href="https://arxiv.org/html/2602.21814v1" target="_blank">Heejin Jo, arXiv 2602.21814</a>
  </footer>

</div>

<script>
function revealAnswer(choice) {
  const reveal = document.getElementById('puzzleReveal');
  const btnWalk = document.getElementById('btnWalk');
  const btnDrive = document.getElementById('btnDrive');

  btnWalk.classList.remove('selected-walk', 'selected-drive');
  btnDrive.classList.remove('selected-walk', 'selected-drive');

  if (choice === 'walk') {
    btnWalk.classList.add('selected-walk');
    reveal.innerHTML = '<strong>每一个主流 LLM 都和你做了同样的选择。</strong>Claude、GPT-4、Gemini、Mistral——全都说走路。但正确答案是开车。原因很简单：<strong>车必须在洗车场才能被洗</strong>。你需要把车开过去，不是把自己走过去。100 米的距离完全是干扰项——关键不在于你怎么到达，而在于车怎么到达。';
  } else {
    btnDrive.classList.add('selected-drive');
    reveal.innerHTML = '<strong>你答对了。</strong>令人意外的是，你击败了所有主流 LLM——Claude、GPT-4、Gemini、Mistral 全都说走路。它们忽略了一个人类立刻就能推断的隐性前提：<strong>车必须在洗车场才能被洗</strong>。100 米的距离是干扰项；关键不在于你怎么到达，而在于车怎么到达。';
  }
  reveal.style.display = 'block';
}

window.addEventListener('scroll', () => {
  const h = document.documentElement;
  const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
  document.getElementById('progress').style.width = Math.min(pct, 100) + '%';
}, { passive: true });

const toc = document.getElementById('toc');
if (toc) {
  const links = [...toc.querySelectorAll('a')];
  const targets = links.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);
  const update = () => {
    let current = '';
    for (const t of targets) {
      if (t.getBoundingClientRect().top <= 140) current = t.id;
    }
    links.forEach(a => a.classList.toggle('active', a.getAttribute('href') === '#' + current));
  };
  window.addEventListener('scroll', update, { passive: true });
  update();
}

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.querySelectorAll('.stair-bar[data-w]').forEach(bar => {
        const w = bar.getAttribute('data-w');
        if (w > 0) bar.style.width = w + '%';
      });
      observer.unobserve(entry.target);
    }
  });
}, { threshold: 0.3 });

const staircase = document.getElementById('staircase');
if (staircase) {
  staircase.querySelectorAll('.stair-bar[data-w]').forEach(bar => {
    if (bar.getAttribute('data-w') > 0) bar.style.width = '0%';
  });
  observer.observe(staircase);
}
</script>

<script defer src="https://cloud.umami.is/script.js" data-website-id="920ac93c-222f-4ac4-9de2-f7cf2d3de4cd"></script>
</body>
</html>
